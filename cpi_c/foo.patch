diff --git a/cpi_c/ir.c b/cpi_c/ir.c
index bf3b8a6..1339136 100644
--- a/cpi_c/ir.c
+++ b/cpi_c/ir.c
@@ -5,8 +5,87 @@
 
 #define TODO assert(!"Todo");
 
-/*
-bool type_is_custom(struct CustomTypes *ts, char *typename) {
-    TODO;
+static void grow(unsigned char **backing_memory, size_t new_sz) {
+    void *ptr = realloc(*backing_memory, new_sz);
+    if (!ptr) assert(!"Realloc failure"); // For now.
+    memset(ptr, 0, new_sz);
+    *backing_memory = ptr;
 }
-*/
+
+// Note: `sz` may be off by +1
+static size_t padded_size(size_t sz, size_t alignment) {
+    sz -= 1;
+    return sz + alignment - (sz % alignment);
+}
+
+void data_container_add(
+    unsigned char *backing_memory,
+    size_t *inout_backing_memory_size,
+    unsigned char *data,
+    size_t data_size_bytes
+) {
+    size_t old_backing_memory_size = *inout_backing_memory_size;
+    size_t new_sz = *inout_backing_memory_size + data_size_bytes;
+    new_sz = padded_size(new_sz, sizeof(intptr_t));
+
+    *inout_backing_memory_size = new_sz;
+    grow(&backing_memory, *inout_backing_memory_size);
+
+    unsigned char *one_past_end_of_first = backing_memory + old_backing_memory_size;
+    memcpy(one_past_end_of_first, data, data_size_bytes);
+}
+
+void label_container_add(
+    unsigned char *backing_memory,
+    size_t *inout_backing_memory_size,
+    intptr_t *inout_based_ptr_latest,
+    char *zstr_name,
+    intptr_t based_ptr_data
+) {
+    size_t old_backing_memory_size = *inout_backing_memory_size;
+    size_t link_sz = sizeof(intptr_t);
+    size_t zstrpadsz_sz = sizeof(intptr_t);
+    size_t zstrpad_sz = padded_size(strlen(zstr_name) + 1, sizeof(intptr_t));
+    size_t ptr_sz = sizeof(intptr_t);
+
+    size_t new_sz = old_backing_memory_size + link_sz + zstrpadsz_sz + zstrpad_sz + ptr_sz;
+    *inout_backing_memory_size = new_sz;
+    grow(&backing_memory, *inout_backing_memory_size);
+
+    unsigned char *base = backing_memory + old_backing_memory_size;
+
+    *(intptr_t *)(base + 0 * sizeof(intptr_t)) = *inout_based_ptr_latest;
+    *inout_based_ptr_latest = base - backing_memory;
+
+    *(intptr_t *)(base + 1 * sizeof(intptr_t)) = zstrpad_sz;
+
+    memset(base + 2 * sizeof(intptr_t), 0, zstrpad_sz);
+    strcpy(base + 2 * sizeof(intptr_t), zstr_name);
+
+    *(intptr_t *)(base + link_sz + zstrpadsz_sz + zstrpad_sz) = based_ptr_data;
+}
+
+intptr_t label_container_find(
+    unsigned char *backing_memory,
+    intptr_t based_ptr_latest,
+    char *search_term
+) {
+    intptr_t ptr = based_ptr_latest;
+    size_t link_sz = sizeof(intptr_t);
+    size_t zstrpadsz_sz = sizeof(intptr_t);
+    char *comparee;
+loop:
+    comparee = backing_memory + ptr + link_sz + zstrpadsz_sz;
+    if (0 == strcmp(comparee, search_term)) {
+        size_t zstrpad_sz = backing_memory + ptr + link_sz;
+        return *(intptr_t *)(backing_memory + link_sz + zstrpadsz_sz + zstrpad_sz);
+    }
+
+    // Not found
+    if (*(intptr_t*)(backing_memory + ptr)) {
+        ptr = *(intptr_t*)(backing_memory + ptr);
+        goto loop;
+    } else {
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/cpi_c/ir.h b/cpi_c/ir.h
index 1994f4d..9f945f9 100644
--- a/cpi_c/ir.h
+++ b/cpi_c/ir.h
@@ -1,236 +1,3 @@
-// IR - Intermediate representation
-//
-// # Statement types
-// - Declarations
-// - Assignments
-// - Branching
-// - Loops
-// - Definitions
-// - Commands
-//
-// # Declarations
-// Every variable or constant has a name. Therefore, the name can be used as a
-// key to map it's value. Declarations dont come with assignments.
-// - Variable
-// - Constant
-// - Array1D
-// - Array2D
-//
-// # Assignments
-// To simplify, this VM will not evaluate expressions. That is the job of the
-// parser. The VM will instead evaluate a simpler form, such as "res" = "arg1"
-// op "arg2" (except for the unary operator)
-// ## Operations
-// Every number is a double. Or a double with it's fractional part truncated and
-// masquerading as an integer.
-// - Addition    |--------------- Has lower predecence
-// - Subtraction |
-// - Multiplication |------------ Has higher predecence
-// - Division       |
-// - Greater than             |-- Has lowest predecence
-// - Lesser than              |
-// - Greater than or equal to |
-// - Lesser than or equal to  |
-// - Not equal to             |
-// - Equal to                 |
-// - Logical AND              |
-// - Logical OR               |
-// - Logical NOT              |
-//
-// # Branching
-// if (condition) instr_ptr += offset;
-// - If
-// - If else
-// - Case
-// - Case otherwise
-//
-// # Loops
-// - For
-// - For with step
-// - Repeat until
-// - While
-//
-// # Definitions
-// - Custom type. "foo.bar.baz" could be a key. Wait, everything's a double or a
-// string.
-// - Procedure (returns nothing)
-// - Function (returns something)
-//
-// # Commands
-// - Call function
-// - Input... A num/string.
-// - Output... A string. Interpreter's job to do the parsing.
-// - File: open, read, write, close, seek
-// - Record: get, put
-
-// Example programs:
-
-//
-// --------------------
-//
-// DECLARE Counter : INTEGER
-// DECLARE TotalToPay : REAL
-// DECLARE GameOver : BOOLEAN
-//
-// --------------------
-//
-// CONSTANT HourlyRate = 6.50
-// CONSTANT DefaultText = "N/A"
-//
-// --------------------
-//
-// Counter  0
-// Counter  Counter + 1
-// TotalToPay  NumberOfHours * HourlyRate
-//
-// --------------------
-//
-// DECLARE StudentNames : ARRAY[1:30] OF STRING
-// DECLARE NoughtsAndCrosses : ARRAY[1:3,1:3] OF CHAR
-//
-// --------------------
-//
-// StudentNames[1]  "Ali"
-// NoughtsAndCrosses[2,3]  ꞌXꞌ
-// StudentNames[n+1]  StudentNames[n]
-// SavedGame  NoughtsAndCrosses
-//
-// INPUT Answer
-// OUTPUT Score
-// OUTPUT "You have ", Lives, " lives left"
-//
-// --------------------
-//
-// TYPE Student
-//   DECLARE Surname : STRING
-//   DECLARE FirstName : STRING
-//   DECLARE DateOfBirth : DATE
-//   DECLARE YearGroup : INTEGER
-//   DECLARE FormGroup : CHAR
-// ENDTYPE
-//
-// ---------------------
-//
-// DECLARE Pupil1 : Student
-// DECLARE Pupil2 : Student
-// DECLARE Form : ARRAY[1:30] OF Student
-//
-// Pupil1.Surname     <- "Johnson"
-// Pupil1.Firstname   <- "Leroy"
-// Pupil1.DateOfBirth <- 02/01/2005
-// Pupil1.YearGroup   <- 6
-// Pupil1.FormGroup   <- ꞌAꞌ
-// Pupil2             <- Pupil1
-//
-// FOR Index <- 1 TO 30
-//   Form[Index].YearGroup <- Form[Index].YearGroup + 1
-// ENDFOR Index
-//
-//OPENFILE StudentFile.Dat FOR RANDOM
-//         FOR Position = 20 TO 10 STEP -1
-//              SEEK StudentFile.Dat, Position
-//              GETRECORD StudentFile.Dat, Pupil
-//              SEEK StudentFile.Dat, Position + 1
-//              PUTRECORD StudentFile.Dat, Pupil
-//ENDFOR
-//         SEEK StudentFile.Dat, 10
-//         PUTRECORD StudentFile.Dat, NewPupil
-//         CLOSEFILE StudentFile.dat
-//
-// --------------------
-//
-// IF ChallengerScore > ChampionScore
-//   THEN
-//     IF ChallengerScore > HighestScore
-//       THEN
-//         OUTPUT ChallengerName, " is champion and highest scorer"
-//       ELSE
-//         OUTPUT Player1Name, " is the new champion"
-//     ENDIF
-//   ELSE
-//     OUTPUT ChampionName, " is still the champion"
-// 	   IF ChampionScore > HighestScore
-//       THEN
-//         OUTPUT ChampionName, " is also the highest scorer"
-//   ENDIF
-// ENDIF
-//
-// ---------------------
-//
-// Total = 0
-// FOR Row = 1 TO MaxRow
-//   RowTotal = 0
-//   FOR Column = 1 TO 10
-//     RowTotal <- RowTotal + Amount[Row,Column]
-//   ENDFOR Column
-//   OUTPUT "Total for Row ", Row, " is ", RowTotal
-//   Total <- Total + RowTotal
-// ENDFOR Row
-// OUTPUT "The grand total is ", Total
-//
-//
-// ---------------------
-//
-// WHILE Number > 9 DO Number  Number – 9
-// ENDWHILE
-// ---------------------
-//
-//  PROCEDURE DefaultSquare
-//    CALL Square(100)
-//  ENDPROCEDURE
-//  PROCEDURE Square(Size : integer)
-//    FOR Side = 1 TO 4
-//      MoveForward Size
-//      Turn 90
-//    ENDFOR
-//  ENDPROCEDURE
-//  IF Size = Default
-//    THEN
-//      CALL DefaultSquare
-//    ELSE
-//      CALL Square(Size)
-//  ENDIF
-//
-// ---------------------
-//
-// FUNCTION Max(Number1:INTEGER, Number2:INTEGER) RETURNS INTEGER
-//   IF Number1 > Number2
-//     THEN
-//       RETURN Number1
-//     ELSE
-//       RETURN Number2
-//   ENDIF
-// ENDFUNCTION
-// OUTPUT "Penalty Fine = ", Max(10,Distance*2)
-//
-// ---------------------
-//
-// // This procedure swaps
-// // values of X and Y
-// PROCEDURE SWAP(BYREF X : INTEGER, Y : INTEGER)
-//   Temp <- X // temporarily store X
-//   X <- Y
-//   Y <- Temp
-// ENDPROCEDURE
-//
-// ---------------------
-//
-//DECLARE LineOfText : STRING
-//            OPENFILE FileA.txt FOR READ
-//            OPENFILE FileB.txt FOR WRITE
-//            WHILE NOT EOF(FileA.txt) DO
-//                 READFILE FileA.txt, LineOfText
-//                 IF LineOfText = ""
-//THEN
-//WRITEFILE FileB.txt, "-------------------------"
-//                   ELSE
-//                     WRITEFILE FILEB.txt, LineOfText
-//                 ENDIF
-//            ENDWHILE
-//            CLOSEFILE FileA.txt
-//            CLOSEFILE FileB.txt
-//
-//
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -239,226 +6,37 @@
 #ifndef IR_H
 #define IR_H
 
-typedef char *OwnedCstr;
-typedef char *BorrowedCStr;
-
-struct ParamDeclVar {
-    OwnedCstr name;
-    OwnedCstr type;
-};
-
-struct ParamDeclVar param_decl_var_new(OwnedCstr name, OwnedCstr type);
-void param_decl_var_free(struct ParamDeclVar *);
-
-struct ParamDeclConst {
-    OwnedCstr name;
-    OwnedCstr type;
-};
-
-struct ParamDeclArr1d {
-    OwnedCstr name;
-    OwnedCstr type;
-    size_t bound_lower;
-    size_t bound_upper;
-};
-
-struct ParamDeclArr2d {
-    OwnedCstr name;
-    OwnedCstr type;
-    size_t dim0_bound_lower;
-    size_t dim0_bound_upper;
-    size_t dim1_bound_lower;
-    size_t dim1_bound_upper;
-};
-
-// This should be a variable. Probably.
-typedef char *TodoType;
-
-// The operation type (add, sub, etc) should be derived from the kind of
-// operation.
-struct ParamAssignment {
-    TodoType result;
-    TodoType param0;
-    TodoType param1;
-};
-
-// "If condition is true, execute this *reigon* of code. Else skip over that
-// reigon."
-struct ParamBrIf {
-    bool condition;
-    size_t if_reigon_len;
-    // if (foo) ... else ... [The else conditoin cannot
-    // exist without the if]
-    size_t else_reigon_len;
-};
-
-struct ParamBrCase {
-    TodoType condition;
-    size_t reigon_len;
-
-    TodoType *values;
-    size_t *value_statement_starts;
-    size_t *value_statement_lengths;
-    size_t value_cnt;
-};
-
-struct ParamLoopFor {
-    OwnedCstr identifier_name;
-    OwnedCstr value0_name;
-    OwnedCstr value1_name;
-    OwnedCstr step_name;
-    size_t reigon_len;
-};
-
-struct ParamLoopRepeatUntil {
-    OwnedCstr condition_name;
-    size_t reigon_len;
-};
-
-struct ParamLoopWhile {
-    OwnedCstr condition_name;
-    size_t reigon_len;
-};
-
-struct ParamDefnCustomType {
-    OwnedCstr name;
-    OwnedCstr type;
-};
-
-struct ParamDefnProcedure {
-    OwnedCstr name;
-    size_t reigon_len;
-};
-
-struct ParamDefnFunction {
-    OwnedCstr name;
-    OwnedCstr ret_value_name;
-    size_t reigon_len;
-};
-
-struct ParamCmdCall {
-    OwnedCstr name;
-};
-
-struct ParamCmdInput {
-    OwnedCstr name;
-};
-
-struct ParamCmdOutput {
-    OwnedCstr str;
-};
-
-struct ParamCmdFileOpen {
-    OwnedCstr identifier;
-    OwnedCstr mode;
-};
-
-struct ParamCmdFileRead {
-    OwnedCstr identifier;
-    OwnedCstr variable;
-};
-
-struct ParamCmdFileWrite {
-    OwnedCstr identifier;
-    OwnedCstr filename;
-};
-
-struct ParamCmdFileClose {
-    TodoType identifier;
-};
-
-struct ParamCmdFileSeek {
-    OwnedCstr identifier;
-    TodoType address;
-};
-
-struct ParamCmdRecordGet {
-    OwnedCstr identifier;
-    TodoType variable;
-};
-
-struct ParamCmdRecordPut {
-    OwnedCstr identifier;
-    TodoType variable;
-};
-
-struct Instr {
-    enum Kind {
-        DECL_VAR,
-        DECL_CONST,
-        DECL_ARR1D,
-        DECL_ARR2D,
-
-        ASS_ADD,
-        ASS_SUB,
-        ASS_MUL,
-        ASS_DIV,
-        ASS_GEQ,
-        ASS_LEQ,
-        ASS_GT,
-        ASS_LT,
-        ASS_EQ,
-        ASS_NEQ,
-        ASS_AND,
-        ASS_OR,
-        ASS_NOT,
-
-        BR_IF,
-        BR_IF_ELSE,
-        BR_CASE,
-        BR_CASE_OTHERWISE,
-
-        LOOP_FOR,
-        LOOP_FOR_STEP,
-        LOOP_REPEAT_UNTIL,
-        LOOP_WHILE,
-
-        DEFN_CUSTOM_TYPE,
-        DEFN_PROCEDURE,
-        DEFN_FUNCTION,
-
-        CMD_CALL,
-        CMD_INPUT,
-        CMD_OUTPUT,
-        CMD_FILE_OPEN,
-        CMD_FILE_READ,
-        CMD_FILE_WRITE,
-        CMD_FILE_CLOSE,
-        CMD_FILE_SEEK,
-        CMD_RECORD_GET,
-        CMD_RECORD_PUT,
-    } kind;
-
-    // All strings are null terminated.
-    // The string may encode a numeric type.
-    union Parameters {
-        struct ParamDeclVar decl_var;
-        struct ParamDeclConst decl_const;
-        struct ParamDeclArr1d decl_arr1d;
-        struct ParamDeclArr2d decl_arr2d;
-        struct ParamAssignment ass;
-        struct ParamBrIf br_if;
-        struct ParamBrCase br_case;
-        struct ParamLoopFor loop_for;
-        struct ParamLoopRepeatUntil loop_repeat_until;
-        struct ParamLoopWhile loop_while;
-        struct ParamDefnCustomType defn_custom_type;
-        struct ParamDefnProcedure defn_procedure;
-        struct ParamDefnFunction defn_function;
-        struct ParamCmdCall call;
-        struct ParamCmdInput input;
-        struct ParamCmdOutput output;
-        struct ParamCmdFileOpen file_open;
-        struct ParamCmdFileRead file_read;
-        struct ParamCmdFileWrite file_write;
-        struct ParamCmdFileClose file_close;
-        struct ParamCmdFileSeek file_seek;
-        struct ParamCmdRecordGet record_get;
-        struct ParamCmdRecordPut record_put;
-    } params;
-};
+// -- Data container --
+// Format: datasz data pad
+// - Size of data, in bytes.
+// - Data.
+// - Optional padding.
+
+void data_container_add(
+    unsigned char *backing_memory,
+    size_t *inout_backing_memory_size,
+    unsigned char *data,
+    size_t data_size_bytes);
+
+// -- Label container --
+// Cell size: intptr_t
+// Format: Link zstrpadsz zstr pad ptr -> (Data container)
+// - Link pointer. Is a null terminated linked list.
+// - Number of bytes needed to contain null terminated string with padding.
+// - Null terminated string.
+// - Optional padding.
+// - Pointer based from backing memory, intptr_t aligned.
+
+void label_container_add(
+    unsigned char *backing_memory,
+    size_t *inout_backing_memory_size,
+    intptr_t *inout_based_ptr_latest,
+    char *zstr_name,
+    intptr_t based_ptr_data);
+
+intptr_t label_container_find(
+    unsigned char *backing_memory,
+    intptr_t based_ptr_latest,
+    char *search_term);
 
-bool type_is_custom(struct CustomTypes *ts, char *typename);
-struct Instr instr_decl_var(char const *const name, char const *const type);
-void instr_free(struct Instr);
 #endif
diff --git a/cpi_c/test.c b/cpi_c/test.c
index 815d577..464c619 100644
--- a/cpi_c/test.c
+++ b/cpi_c/test.c
@@ -1,5 +1,9 @@
-﻿#include <assert.h>
+﻿#include <stdio.h>
+#include <stdlib.h>
+
+#include <assert.h>
 #include "vm.h"
+#include "ir.h"
 
 // -----------------------------------------------------------------
 
@@ -30,6 +34,8 @@
 //#define CP_LOG(FMT_MSG, ...) CP_LEVEL_LOG("Log", FMT_MSG, __VA_ARGS__)
 #define CP_WARN(FMT_MSG, ...) CP_LEVEL_LOG("Warning", FMT_MSG, __VA_ARGS__)
 
+
+
 #define MAX_TESTS (0x80)
 typedef struct Tests {
     bool (*(fns[MAX_TESTS]))(void);
@@ -478,7 +484,32 @@ static bool test__example__handling_random_files(void) {
 
 // ---------------------------------------------------------
 
+static bool test__container(void) {
+// -- Label container --
+// Cell size: intptr_t
+// Format: Link zstrpadsz zstr pad ptr -> (Data container)
+// - Link pointer. Is a null terminated linked list.
+// - Number of bytes needed to contain null terminated string with padding.
+// - Null terminated string.
+// - Optional padding.
+// - Pointer based from backing memory, intptr_t aligned.
+
+    size_t backing_memory_size = 8;
+    unsigned char *backing_memory = malloc(backing_memory_size);
+    intptr_t latest = 0;
+    intptr_t content = 0xDEADBEEF000FAAAA;
+    
+    label_container_add(backing_memory, &backing_memory_size, &latest, "FooBarr", content);
+    return content == label_container_find(backing_memory, latest, "FooBarr")
+        && 0 == label_container_find(backing_memory, latest, "BarrFoo");
+
+}
+
+// ---------------------------------------------------------
+
+
 int main(void) {
+
     CP_ADD_TEST(test__upper);
     CP_ADD_TEST(test__vm_guess_stmt_kind_from_first_word__DECLARE);
     CP_ADD_TEST(test__vm_exec_stmt__DECLARE_name_and_type_extraction);
@@ -507,7 +538,11 @@ int main(void) {
     CP_ADD_TEST(test__example__file_handling_operations);
     CP_ADD_TEST(test__example__handling_random_files);
 
+    CP_ADD_TEST(test__container);
+
     CP_RUN_TESTS();
 
     return 0;
 }
+   
+
diff --git a/cpi_c/vm.c b/cpi_c/vm.c
index 77146dd..4b8ede9 100644
--- a/cpi_c/vm.c
+++ b/cpi_c/vm.c
@@ -39,6 +39,13 @@ void vm_guess_stmt_kind_from_first_word(char *stmt_ptr, enum StatementGuess *out
     }
 }
 
+void grow(unsigned char **mem, size_t new_sz) {
+    void *ptr = realloc(*mem, new_sz);
+    assert(ptr); // For now.
+    memset(ptr, 0, new_sz);
+    *mem = ptr;
+}
+
 static bool skip_whitespace(char **pstr) {
     bool found = false;
     do {
@@ -208,6 +215,26 @@ static void vm_decl_var_in_current_scope(
     vm_add_var(state, name, name_len, type, type_len);
 }
 
+void program_data_append(struct ProgramData *pd, char *zstr, void *data, size_t dat_len) {
+    size_t alignment = 8; //_Alignof(size_t);
+    size_t slen = strlen(zstr) + 1;
+    slen += alignment - (slen % alignment);
+
+    size_t append_len = sizeof (struct Header) + slen + dat_len;
+    pd->mem_sz += append_len;
+
+    grow(&pd->mem, pd->mem_sz);
+
+    // Fill out header
+    struct Header header;
+    header.next = pd->latest_header;
+    header.str;
+
+    // Memcpy string
+
+    // Memcpy data
+}
+
 void vm_exec_stmt(struct VmState *state, char *stmt_ptr) {
     size_t len;
     enum StatementGuess guess;
diff --git a/cpi_c/vm.h b/cpi_c/vm.h
index 7d35129..c2dc288 100644
--- a/cpi_c/vm.h
+++ b/cpi_c/vm.h
@@ -18,7 +18,69 @@
 // - As function parameter, may be passed by value or reference
 // - Is an array type
 //
-// Most frequent operation is name lookup
+
+// # Statement types
+// - Declarations
+// - Assignments
+// - Branching
+// - Loops
+// - Definitions
+// - Commands
+//
+// # Declarations
+// Every variable or constant has a name. Therefore, the name can be used as a
+// key to map it's value. Declarations dont come with assignments.
+// - Variable
+// - Constant
+// - Array1D
+// - Array2D
+//
+// # Assignments
+// To simplify, this VM will not evaluate expressions. That is the job of the
+// parser. The VM will instead evaluate a simpler form, such as "res" = "arg1"
+// op "arg2" (except for the unary operator)
+// ## Operations
+// Every number is a double. Or a double with it's fractional part truncated and
+// masquerading as an integer.
+// - Addition    |--------------- Has lower predecence
+// - Subtraction |
+// - Multiplication |------------ Has higher predecence
+// - Division       |
+// - Greater than             |-- Has lowest predecence
+// - Lesser than              |
+// - Greater than or equal to |
+// - Lesser than or equal to  |
+// - Not equal to             |
+// - Equal to                 |
+// - Logical AND              |
+// - Logical OR               |
+// - Logical NOT              |
+//
+// # Branching
+// if (condition) instr_ptr += offset;
+// - If
+// - If else
+// - Case
+// - Case otherwise
+//
+// # Loops
+// - For
+// - For with step
+// - Repeat until
+// - While
+//
+// # Definitions
+// - Custom type. "foo.bar.baz" could be a key. Wait, everything's a double or a
+// string.
+// - Procedure (returns nothing)
+// - Function (returns something)
+//
+// # Commands
+// - Call function
+// - Input... A num/string.
+// - Output... A string. Interpreter's job to do the parsing.
+// - File: open, read, write, close, seek
+// - Record: get, put
 
 enum StatementGuess {
     STMT_DECLARE,
@@ -28,6 +90,26 @@ enum StatementGuess {
 char upper(char c);
 void vm_guess_stmt_kind_from_first_word(char *stmt_ptr, enum StatementGuess *out_sg, size_t *out_stmt_len);
 
+void grow(unsigned char **mem, size_t new_sz);
+
+// Struct members are indices to a char* array instead of pointers
+// Avoids pointer invalidation
+struct Header {
+    size_t next;
+    size_t str;
+    size_t strlen;
+    size_t data;
+    size_t datalen;
+};
+
+struct ProgramData {
+    char *mem;
+    size_t mem_sz;
+    size_t latest_header;
+};
+
+void program_data_append(struct ProgramData *pd, char *zstr, void *data, size_t dat_len);
+
 #define VAR_NAME_LEN ((size_t)8)
 struct VmState {
     size_t one_above_top;
